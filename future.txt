# from torch import nn
# from sklearn.utils.class_weight import compute_class_weight

# weights = compute_class_weight(class_weight="balanced", classes=train_df["label"].unique(), y=train_df["label"])

# class WeightedTrainer(Trainer):
#     def compute_loss(self, model, inputs, num_items_in_batch, return_outputs=False, ):
#         labels = inputs.get("labels")
#         # forward pass
#         outputs = model(**inputs)
#         logits = outputs.get('logits')
#         # compute custom loss
#         loss_fct = nn.CrossEntropyLoss(weight=torch.tensor(weights))
#         loss = loss_fct(logits.view(-1, self.model.config.num_labels), labels.view(-1))
#         return (loss, outputs) if return_outputs else loss


# from transformers import Trainer

# trainer = WeightedTrainer(
#     model,
#     training_args,
#     train_dataset=tokenized_datasets["train"],
#     eval_dataset=tokenized_datasets["validation"],
#     data_collator=data_collator,
#     processing_class=tokenizer,
#     compute_metrics=compute_metrics
# )
